---
alwaysApply: true
name: "Code Style & Conventions"
description: "Consistent code style, naming conventions, TypeScript patterns, and code quality standards across the codebase."
globs: ["src/**/*.{ts,tsx,scss}"]
priority: medium
---

# Intent

Maintain strict and consistent code conventions for style, naming, TypeScript patterns, and code quality, independent of architecture.

## CRITICAL RULES - CODE CONVENTIONS NEVER OPTIONAL

### 1. Language - ENGLISH ONLY - STRICT ENFORCEMENT

-   **ALWAYS** write all code, comments, documentation, JSDoc, and documentation files in **English**
-   **ALWAYS** write all Jira tickets, planning documents, and reports in **English**
-   **ALWAYS** use English for variable names, function names, type names, and all identifiers
-   **ALWAYS** use English for error messages, console logs, and user-facing strings (unless explicitly required otherwise)
-   **NEVER** use French or any other language in code, comments, or documentation
-   **NEVER** create tickets, plans, or reports in French or other languages
-   **ALWAYS** translate any non-English content to English before committing

**This rule applies to:**

-   Source code (`src/**/*.{ts,tsx}`)
-   Documentation files (`*.md`, `*.mdx`)
-   Jira tickets (`jira/*.md`)
-   Planning documents (`report/planning/*.md`)
-   Reports and audits (`report/**/*.md`)
-   Comments and JSDoc in code
-   Test files (`__tests__/**/*.{ts,tsx}`)

**Exception:** User-facing UI text (labels, buttons, etc.) may be in French if required by business needs, but all code, comments, and technical documentation must be in English.

### 2. TypeScript Style - STRICT ENFORCEMENT

-   **ALWAYS** use TypeScript strict at all times
-   **NEVER** use `any` - always type explicitly
-   **ALWAYS** prefer explicit types
-   **ALWAYS** write short, readable, and pure functions
-   **NEVER** create unnecessarily complex logic

### 2. Control statements must use braces

-   **ALWAYS** wrap control statements with braces, even for single statements.

### 3. SCSS / Styling - MANDATORY STRUCTURE

#### SCSS Structure

-   **ALWAYS** place global SCSS in `styles/global.scss`
-   **ALWAYS** place variables in `styles/variables/*`
-   **ALWAYS** place UI components in `styles/components/*`

#### SCSS Variables - MANDATORY USAGE

-   **ALWAYS** use only variables from `styles/variables/*` for all styles
-   **NEVER** create styles with hardcoded values (colors, spacing, sizes, etc.)
-   **ALWAYS** if a variable doesn't exist in `styles/variables/*`, add it to the dedicated section of the appropriate file
-   **NEVER** use direct values (e.g., `#fff`, `16px`, `1rem`) without using a variable

#### SCSS Naming Rules

-   **ALWAYS** name classes in kebab-case: `.product-card`
-   **ALWAYS** use `__` for sub-elements: `.product-card__title`
-   **ALWAYS** use `--` for variations: `.button--primary`
-   **NEVER** use inline CSS in React components
-   **NEVER** use `!important`

### 4. React / Next.js Components - STRICT PATTERNS

#### Component Format

-   **ALWAYS** use arrow function with export default
-   **NEVER** use ES6 classes
-   **NEVER** use `export function`
-   **ALWAYS** name components in PascalCase
-   **ALWAYS** use `const ComponentName = () => {}`
-   **ALWAYS** use `export default ComponentName` at the end

**Mandatory structure:**

```typescript
const ComponentName = () => {
    // ...
};

export default ComponentName;
```

#### Props

-   **ALWAYS** define props type above the component
-   **ALWAYS** use `type` for props (never `interface`)

**Mandatory structure:**

```typescript
type Props = {
    products: Product[];
};

const ProductList = ({ products }: Props) => {
    // ...
};

export default ProductList;
```

#### JSX

-   **NEVER** make network calls in JSX
-   **NEVER** put business logic in JSX
-   **NEVER** do heavy calculations in JSX
-   **ALWAYS** use `&&` or ternaries for conditions
-   **NEVER** use `if` in JSX

#### Files

-   **ALWAYS** use `.tsx` extension for components
-   **ALWAYS** respect: one file = one main component

### 5. Zustand Stores - UI STATE ONLY

-   **ALWAYS** create one store per UI state domain (filters, modals, selection, theme, etc.)
-   **NEVER** put side effects in stores
-   **NEVER** create direct link with Supabase, React Query, or business logic
-   **ALWAYS** name stores: `useXxxStore.ts`

**Mandatory structure:**

```typescript
export const useFilterStore = create<FilterState>((set) => ({
    search: "",
    setSearch: (v) => set({ search: v }),
}));
```

### 6. React Query Hooks - DATA FETCHING PATTERNS

-   **ALWAYS** create one hook per resource: `useProducts`, `useStockMovements`, etc.
-   **ALWAYS** use explicit and stable queryKey: `queryKey: ["products"]`
-   **NEVER** make direct Supabase call - only execute a usecase
-   **ALWAYS** return: `data`, `isLoading`, `error`

**Mandatory structure:**

```typescript
export function useProducts() {
    return useQuery({
        queryKey: ["products"],
        queryFn: () => listProducts(productRepositorySupabase),
    });
}
```

### 7. Types & Naming - STRICT CONVENTIONS

#### Types

-   **ALWAYS** place business types in `core/domain` and use them everywhere via imports
-   **NEVER** use prefixes (no `IProduct`, `IUser`)
-   **ALWAYS** prefer: `Product`, `StockMovement`

#### Interface vs Type vs Enum

-   **ALWAYS** use `interface` **ONLY** for classes
-   **ALWAYS** use `type` for everything else (props, objects, unions, intersections, etc.)
-   **ALWAYS** use `enum` for enumerated constants

**Mandatory examples:**

```typescript
// ✅ Interface only for classes
interface IRepository {
    list(): Promise<Product[]>;
}

class ProductRepository implements IRepository {
    // ...
}

// ✅ Type for props, objects, etc.
type Product = {
    id: string;
    name: string;
};

type Props = {
    products: Product[];
};

// ✅ Enum for constants
enum ProductStatus {
    ACTIVE = "active",
    INACTIVE = "inactive",
}
```

#### Naming

-   **ALWAYS** use camelCase for variables and functions
-   **ALWAYS** use PascalCase for types / components

#### File Naming

-   `ProductTable.tsx` → Component
-   `useProducts.ts` → React Query hook
-   `useProductFilterStore.ts` → Zustand store
-   `productRepositorySupabase.ts` → Infrastructure repository

### 8. Tests - MANDATORY COVERAGE

-   **ALWAYS** write unit tests for `domain` and `usecases`
-   **NEVER** make UI tests mandatory for page components
-   **ALWAYS** write mandatory tests for reusable components in `presentation/components/ui`

### 9. Imports - ORDER AND CLEANLINESS

#### Mandatory Order

1. External libraries (React, Zustand, React Query…)
2. Types / domain
3. Usecases
4. Infrastructure
5. Presentation (components, hooks, stores)
6. Styles or SCSS modules
7. Relative imports

#### Import Path Rules

-   **ALWAYS** use absolute imports with `@/` prefix for all imports from `src/`
-   **NEVER** use relative imports (`../`, `../../`, etc.) for imports from `src/`
-   **ALWAYS** use `@/` to reference files in `src/` directory
-   **NEVER** use relative paths like `../../src/` or `../../../src/`
-   **ALWAYS** use `@/styles/` for SCSS imports from `src/styles/`
-   **NEVER** use relative paths like `../../../styles/` in SCSS files

**Examples:**

```typescript
// ✅ Correct - Absolute import
import Link from "@/presentation/components/ui/Link";
import { useAuthStore } from "@/presentation/stores/useAuthStore";
import { signInUser } from "@/core/usecases/auth";

// ❌ Wrong - Relative import
import Link from "../../../../src/presentation/components/ui/Link";
import { useAuthStore } from "../stores/useAuthStore";
import { signInUser } from "../../core/usecases/auth";
```

```scss
// ✅ Correct - Absolute import in SCSS
@use "@/styles/variables/colors" as *;
@use "@/styles/variables/spacing" as *;

// ❌ Wrong - Relative import in SCSS
@use "../../../styles/variables/colors" as *;
@use "../../../styles/variables/spacing" as *;
```

#### Rules

-   **ALWAYS** remove unused imports

### 10. Code Quality - BEST PRACTICES

-   **ALWAYS** name functions according to what they actually do
-   **ALWAYS** prefer pure functions
-   **ALWAYS** split components that are too long
-   **ALWAYS** use `async/await` rather than `.then()`
-   **ALWAYS** type return values of public functions
-   **NEVER** ignore a network error (always at least a `throw`)

## CODE CONVENTION VIOLATIONS - AUTO-STOP CONDITIONS

### 11. Critical Violations - ALWAYS STOP

1. **Non-English content in code/documentation** → STOP and translate to English
2. **Use of `any`** → STOP and type explicitly
3. **Inline CSS in component** → STOP and use SCSS
4. **Hardcoded value in SCSS** → STOP and create/use a variable in `styles/variables/*`
5. **`export function` for component** → STOP and use `const ComponentName = () => {}`
6. **`interface` for props** → STOP and use `type`
7. **`if` in JSX** → STOP and use `&&` or ternary
8. **Business logic in JSX** → STOP and move to a hook or usecase
9. **Network call in component** → STOP and use a React Query hook
10. **Side effect in Zustand store** → STOP and move the logic
11. **Unused imports** → STOP and remove
12. **Function without return type** → STOP and type explicitly
13. **Relative imports from `src/`** → STOP and use absolute imports with `@/`
14. **Relative SCSS imports from `styles/`** → STOP and use `@/styles/` instead

## CODE CONVENTION COMPLIANCE - MANDATORY VERIFICATION

### 12. Zod Schemas – STRICT VALIDATION RULES

## Zod Placement Rules

-   **ALWAYS** place all Zod schemas inside the domain or inside /core/domain/schemas
-   **NEVER** create Zod schemas in components, hooks, or presentation layer
-   **ALWAYS** group schemas by domain (Product, Activity, StockMovement…)

## Schema Naming

-   **ALWAYS** name schemas with the suffix Schema
    Example:

```ts
const ProductSchema = z.object({
    id: z.string(),
    name: z.string(),
});
```

-   **ALWAYS** create a TypeScript type using z.infer<typeof Schema>
-   **NEVER** write a duplicated interface or type manually for what the schema already defines

## Validation Rules

-   **ALWAYS** validate external data (Supabase, network, forms) using Zod
-   **ALWAYS** validate user input inside usecases, never in UI
-   **NEVER** validate inside React components or Zustand stores
-   **ALWAYS** throw a domain error when validation fails

## Zod + Usecases – MANDATORY PATTERN

Every usecase that receives input must validate it:

```ts
export async function createProduct(input: CreateProductInput): Promise<Product> {
    const parsed = CreateProductSchema.parse(input);
    return productRepository.create(parsed);
}

Types Derived From Zod – MANDATORY
export type Product = z.infer<typeof ProductSchema>;
export type CreateProductInput = z.infer<typeof CreateProductSchema>;
```

No duplicated types.
No manual interfaces.

## Structure Example (MANDATORY)

core/
domain/
product/
product.schema.ts ← All schemas
product.types.ts ← all z.infer exported types
product.entity.ts ← domain entity if needed

## React Query + Zod

-   **ALWAYS** validate server data inside the usecase, before returning
-   **NEVER** validate inside React Query hook

### 13. Code Generation Checklist

Before EVERY code generation:

✅ **Language**

-   All code, comments, and documentation in English?
-   All tickets, plans, and reports in English?
-   All variable/function/type names in English?

✅ **TypeScript**

-   TypeScript strict enabled?
-   No `any` used?
-   Explicit types everywhere?

✅ **Components**

-   Arrow function format with export default?
-   Props typed with `type`?
-   No business logic in JSX?

✅ **Styling**

-   SCSS in correct directories?
-   All values use variables from `styles/variables/*`?
-   Missing variables added in `styles/variables/*`?
-   Classes in kebab-case?
-   No inline CSS?
-   No hardcoded values?

✅ **State Management**

-   Zustand store for UI state only?
-   React Query hook calls a usecase?
-   No side effects in stores?

✅ **Types**

-   `interface` only for classes?
-   `type` for props and objects?
-   `enum` for constants?

✅ **Imports**

-   Order respected?
-   Absolute imports with `@/` used for all `src/` imports?
-   SCSS imports use `@/styles/` instead of relative paths?
-   Unused imports removed?

✅ **Code Quality**

-   Pure functions preferred?
-   Explicit return types?
-   Appropriate error handling?

This ensures consistent, maintainable, and high-quality code across the entire codebase.
